
//PROTO_KERNEL_START
//void
//f_RKTaylorCoefsF(Var<double,RKORDER*(NUMCOMPS)>& a_UTaylor,
//              Var<double,NUMCOMPS>& a_kstage,
//              Var<double,NUMCOMPS>& a_U,
//              int a_stage
//              )
template<unsigned int C>
PROTO_KERNEL_START
void
f_RKTaylorCoefsF(Var<double,RKORDER*(C)>& a_UTaylor,
              Var<double,C>& a_kstage,
              Var<double,C>& a_U,
              int a_stage
              )
{
    for (int n = 0; n < C;n++)
    {
        if (a_stage == 0) 
        {
            a_UTaylor(n*RKORDER) = a_U(n);
            a_UTaylor(1 + n*RKORDER) = a_kstage(n);
            a_UTaylor(2 + n*RKORDER) = -(3.0/2)*a_kstage(n);
            a_UTaylor(3 + n*RKORDER) = (2.0/3)*a_kstage(n);
        }
        if (a_stage == 1)
        {
            a_UTaylor(2 + n*RKORDER) += a_kstage(n);
            a_UTaylor(3 + n*RKORDER) += (-2.0/3)*a_kstage(n);
        }
        if (a_stage == 2)
        {
            a_UTaylor(2 + n*RKORDER) += a_kstage(n);
            a_UTaylor(3 + n*RKORDER) += (-2.0/3)*a_kstage(n);

        }
        if (a_stage == 3)
        {
            a_UTaylor(2 + n*RKORDER) += (-1.0/2)*a_kstage(n);
            a_UTaylor(3 + n*RKORDER) += (2.0/3)*a_kstage(n);
        }
    }
}
PROTO_KERNEL_END(f_RKTaylorCoefsF, f_RKTaylorCoefs)

template<unsigned int C>
PROTO_KERNEL_START
void
f_RKTimeInterpF(Var<double,C>& a_U,
    Var<double,RKORDER*(C)>& a_UTaylor,
    double& a_chi)
{
    for (int n = 0; n < C;n++)
    {
        a_U(n) = 0.;
        for (int term = 0; term < RKORDER; term++)
        {
            a_U(n) = a_U(n)*a_chi + a_UTaylor(RKORDER-term-1 + n*RKORDER);
        }
    }
}
PROTO_KERNEL_END(f_RKTimeInterpF,f_RKTimeInterp)

template<unsigned int C>
PROTO_KERNEL_START
void f_stageUpdateF(
    Var<double,C>& a_UStage,
    Var<double,C>& a_rhsTot,
    const Var<double,C>& a_U0,
    const Var<double,C>& a_kStage,
    const double& a_dtStageNext,
    const double& a_stageWeight)
{
    for (int comp = 0; comp < C; comp++)
    {
        a_rhsTot(comp) += a_stageWeight*a_kStage(comp);
        a_UStage(comp) = a_U0(comp) + a_dtStageNext*a_kStage(comp); 
    }
}
PROTO_KERNEL_END(f_stageUpdateF,f_stageUpdate)

template<template<typename, MemType> class OpType,typename T,MemType MEM>
AMRRK4<OpType,T,MEM>::AMRRK4(
                             AMRStateData& a_data,
                             const Array<T, DIM>& a_dx,
                             int a_regridInterval,
                             int a_bufferSize)
{
    define(a_data, a_dx, 0,a_regridInterval,a_bufferSize);
}

template<typename T>
void trimVector(std::vector<T>& a_vector, unsigned int a_size)
{
    while (a_vector.size() > a_size)
    {
        a_vector.pop_back();
    }
}

template<
    template<typename, MemType> class OpType,typename T,MemType MEM>
void AMRRK4<OpType,T,MEM>::define(
                                  AMRStateData& a_data,
                                  const Array<T, DIM>& a_dx,
                                  int a_regridInterval,
                                  int a_bufferSize)
{
    define(a_data, a_dx, 0 ,a_regridInterval,a_bufferSize);
}

template<
    template<typename, MemType> class OpType, typename T, MemType MEM>
void AMRRK4<OpType,T,MEM>::define(
                                  AMRStateData& a_data,
                                  const Array<T, DIM>& a_dx,
                                  int                 a_level,
                                  int                 a_regridInterval,
                                  int                 a_bufferSize)
{
     PR_TIMERS("AMRRK4::define");
    // dont do anything fancy, just kill everything and redefine
    if (a_level == 0)
    {
        int numLevels = a_data.grid().numLevels();
        
        m_UStage.clear();
        m_UTaylor.clear();
        m_UTaylorC.clear();
        m_fluxRegisters.clear();
        m_ops.clear();
        
        m_UStage.resize(numLevels);
        m_UTaylor.resize(numLevels - 1);
        m_UTaylorC.resize(numLevels - 1);
        m_fluxRegisters.resize(numLevels - 1);       

        //m_ops.resize(numLevels);
        if (m_numSteps.size() != numLevels)
        {
            m_numSteps= std::vector<int>(numLevels,0);
        }
        m_timeRefRatios.resize(numLevels - 1);
        m_spaceRefRatios.resize(numLevels - 1);
        m_regridInterval.resize(numLevels - 1);
        m_bufferSize.resize(numLevels - 1);
        m_cfInterp.resize(numLevels - 1);
        
        m_data = &a_data;
        Array<T, DIM> dx = a_dx;
        for (int lvl = a_level; lvl < numLevels; lvl++)
        {
            auto& layout = a_data.grid()[lvl];
            
            m_ops.push_back(LOP(layout, dx));
            //m_ops[lvl].define(layout, dx);
            m_UStage[lvl] = std::make_shared<LevelBoxData<T, OP::numState(), MEM>>(
                    layout, OP::ghost());
            m_UStage[lvl]->setToZero();
            if (lvl < numLevels-1)
            {
                auto& fineLayout = a_data.grid()[lvl+1];
                Point spaceRefRatio = a_data.grid().refRatio(lvl);
                auto cfLayout = fineLayout.coarsen(spaceRefRatio);

                m_regridInterval[lvl] = a_regridInterval;
                m_bufferSize[lvl] = a_bufferSize;
                m_spaceRefRatios[lvl] = spaceRefRatio;
                m_timeRefRatios[lvl] = spaceRefRatio.max();
                m_cfInterp[lvl] = InterpStencil<T>::FiniteVolume(spaceRefRatio, OP::order());
                m_UTaylor[lvl] =
                    std::make_shared<LevelBoxData<T, OP::numState()*RKORDER, MEM>>(
                            layout, Point::Zeros());
                m_UTaylor[lvl]->setToZero();
                m_fluxRegisters[lvl] =
                    std::make_shared<LevelFluxRegister<T, OP::numState(), MEM>>(
                            layout, fineLayout, spaceRefRatio, dx);

                m_fluxRegisters[lvl]->reset();
                // Point::Ones() are here to make the division a ceil instead of a floor
                Point interpGhost = OP::ghost() / spaceRefRatio + Point::Ones();
                interpGhost += m_cfInterp[lvl].ghost();

                m_UTaylorC[lvl] =
                    std::make_shared<LevelBoxData<T, OP::numState()*RKORDER, MEM>>(
                            cfLayout, interpGhost);
                m_UTaylorC[lvl]->setToZero();
                for (int dir = 0; dir < DIM; dir++)
                {
                    dx[dir] /= spaceRefRatio[dir];
                }
            }
        }
    }
    // leave coarse level stuff alone and only redefine things on the finer levels
    else 
    {
        int numLevels = a_data.grid().numLevels();
        trimVector(m_UStage,        a_level);
        trimVector(m_UTaylor,       a_level);
        trimVector(m_UTaylorC,      a_level);
        trimVector(m_fluxRegisters, a_level);

        //m_ops.resize(numLevels);
        //m_numSteps.resize(numLevels);
        m_regridInterval.resize(numLevels-1);
        m_bufferSize.resize(numLevels-1);
        m_timeRefRatios.resize(numLevels - 1);
        m_spaceRefRatios.resize(numLevels - 1);
        m_cfInterp.resize(numLevels - 1);
        
        m_data = &a_data;

        Array<T, DIM> dx = a_dx;
        for (int lvl = a_level; lvl < numLevels; lvl++)
        {
            auto& layout = a_data.grid()[lvl];
            m_ops.push_back(LOP(layout, dx));
            //m_ops[lvl].define(layout, dx);
            m_UStage.push_back(
                    std::make_shared<LevelBoxData<T, OP::numState(), MEM>>(
                        layout, OP::ghost()));
            //m_numSteps[lvl] = 0;
            if (lvl < numLevels-1)
            {
                auto& fineLayout = a_data.grid()[lvl+1];
                Point spaceRefRatio = a_data.grid().refRatio(lvl);
                auto cfLayout = fineLayout.coarsen(spaceRefRatio);

                m_spaceRefRatios[lvl] = spaceRefRatio;
                m_timeRefRatios[lvl] = spaceRefRatio.max();
                m_regridInterval[lvl] = a_regridInterval;
                m_bufferSize[lvl] = a_bufferSize;
                m_cfInterp[lvl] = InterpStencil<T>::FiniteVolume(spaceRefRatio, OP::order());
                m_UTaylor.push_back(
                        std::make_shared<LevelBoxData<T, OP::numState()*RKORDER, MEM>>(
                            layout, Point::Zeros()));
                m_fluxRegisters.push_back(
                        std::make_shared<LevelFluxRegister<T, OP::numState(), MEM>>(
                            layout, fineLayout, spaceRefRatio, dx));

                // Point::Ones() are here to make the division a ceil instead of a floor
                Point interpGhost = OP::ghost() / spaceRefRatio + Point::Ones();
                interpGhost += m_cfInterp[lvl].ghost();

                m_UTaylorC.push_back(
                        std::make_shared<LevelBoxData<T, OP::numState()*RKORDER, MEM>>(
                            cfLayout, interpGhost));
                for (int dir = 0; dir < DIM; dir++)
                {
                    dx[dir] /= spaceRefRatio[dir];
                }
            }
        }
        PROTO_ASSERT(m_RHSTotal.size() == numLevels, 
                "AMRRK4::define | Error: Wrong number of elements.");
        PROTO_ASSERT(m_UTaylor.size() == numLevels - 1, 
                "AMRRK4::define | Error: Wrong number of elements.");
        PROTO_ASSERT(m_UTaylorC.size() == numLevels - 1, 
                "AMRRK4::define | Error: Wrong number of elements.");
        PROTO_ASSERT(m_fluxRegisters.size() == numLevels - 1, 
                "AMRRK4::define | Error: Wrong number of elements.");
    }
}

template< template<typename, MemType> class OpType,typename T,MemType MEM>
void AMRRK4<OpType,T,MEM>::advance(T a_dt)
{
    advance(0, a_dt, 0);
}
template< template<typename, MemType> class OpType,typename T,MemType MEM>
void AMRRK4<OpType,T,MEM>::StageLevel(
                                      LevelStateData& a_kstage,
                                      const LevelStateData& a_UStage,
                                      T a_dt,
                                      T a_time,
                                      int a_level,
                                      int a_stage)
{
  auto layoutCoarsened = m_layout[a_level].coarsen(m_refRatio[a_level]);
  Point ghostInterp; // number of ghost cells required for interpolation.
  for (dir = 0; dir < DIM; dir++)
    {
      int q = OP::ghost()[dir]/m_refRatio[a_level][dir];
      if (q*m_refRatio[a_level][dir] < OP::ghost()[dir]) q++;
      ghostInterp[dir] = q + 2;
    }
  LevelStateData UCoarsened(layoutCoarsened,ghostInterp);
  
  chi = (m_chi[a_stage]*m_dt[a_level] + m_time[a_level] -
         m_time[a_level-1])/m_dt[a_level-1]);
// fraction of coarse time step we are interpolating to.
  interpTime(UCoarsened,a_level,a_stage),chi);
// Call Level Operator.
  LOP::applyOp(a_kstage,a_UStage,a_UCoarsened,
               m_blockreg[a_level],m_levelfr[a_level],
               m_refRatio[a_level],a_dt,a_time,a_level,a_stage);
}
template< template<typename, MemType> class OpType,typename T,MemType MEM>
void AMRRK4<OpType,T,MEM>::advance(T a_dt,T a_time,int a_level)
{
  // manages the refinement in time evolution. Calls AMRRK4::StageLevel to compute
  // stage RHS using LOP member functions and AMRRK4 Interpolation functions.
   
    LevelStateData delta(m_layout[a_level],Point::Zeros());
    LevelStateData UStage(m_layout[a_level],OP:ghost());
    delta.setVal(0.);
    m_blockRegisters[a_level].clear();
    
    if (a_level < m_maxlev)
      {
        m_fluxRegisters[a_level]->clear();
      }
    // Begin RK4 time stepping.
    m_data[a_level].copyTo(UStage);
    for (int stage = 0; stage < RKNUMSTAGES; stage++)
    {
      StageLevel(kstage,U0,a_time, a_dt, stage);
      m_delta[a_level].increment(m_k, stageWeight[stage]*a_dt);
      m_data->copyTo(m_U0);
      if (kstage < RKSTAGES - 1)
        {
          m_data[a_level]->copyTo(UStage);
          UStage.increment(kstage,a_dt*chi[a_level+1]);
        }
    }    
    // recursive call to next finer level
    
    for (int timeIter = 0; timeIter < m_timeRefRatio[a_level];timeIter++)
      {
        dtFine = m_dt[a_level+1];
        T timeFine = timeIter*dtFine + m_time[a_level];
        advance(dtFine,timeFine,a_level+1);
      }
    // Update registers on a_level. We could update the blockRegister earlier, but
    // I'm anticipating that the block register may end up being modified by the
    // contents of the flux register.
    m_blockRegisters[a_level].reflux(delta);
    if (a_level < m_maxlev)
      {
        m_levelfr.reflux(delta);
      }
    m_data[a_level]->increment(delta,1.0);
    // We're done with the a_level time step. update m_numSteps, m_time.
    m_numSteps[a_level]++;
    m_time[a_lev] += m_dt[a_level];
    // Do Regridding
    if (a_level < m_data->numLevels() - 1)
      {
        bool regridThisLevel = false;
        if (a_level  == 0)
          {
            regridThisLevel = (m_numSteps[0]%m_regridInterval[0] == 0);
          }
        else
          {                              
            regridThisLevel = (m_numSteps[a_level]%m_regridInterval[a_level] == 0) 
              && ((m_numSteps[a_level])%
                  ((m_timeRefRatios[a_level-1])*m_regridInterval[a_level-1]) != 0);
          }  
        if (regridThisLevel)
          {
            regrid(a_level);
          }
      }
}
template< template<typename, MemType> class OpType,typename T,MemType MEM>
void AMRRK4<OpType,T,MEM>::UTimeInterp(LevelStateData& a_UCoarsened,
                                       int a_level,
                                       int a_stage,
                                       T a_chi)
{
    LevelStateData UTimeInterp(m_layout[a_level-1],Point::Zeros());
    // Interpolate from next coarser level.
    for (auto iter : m_layout[a_level-1])
    {
      auto& UTimeInterp_i   = UTimeInterp[iter];
      auto& UTaylorC_i = *UTaylorC[iter];           
      // interpolate in time
      forall<T, OP::numState()>(f_RKTimeInterp, UTimeInterp_i, UTaylorC_i, a_chi);
    }
    // copy to coarsend fine data.
    UTimeInterp.copyTo(a_UCoarsened);
}
template<template<typename, MemType> class OpType,typename T, MemType MEM>
void AMRRK4<OpType,T,MEM>::regrid(int a_baseLevel)
{
    AMRGrid newGrids = m_data->grid();

    // for all coarse levels (finest to coarsest)
    for (int level = m_data->numLevels()-2; level >= a_baseLevel; level--)
    {
        auto& layout = newGrids[level];

        // Compute tags on this level
        LevelTagData tags(layout, Point::Ones(m_bufferSize[level]));
        tags.setToZero();
        for (auto iter : layout)
        {
            auto& tags_i = tags[iter];
            auto& U0_i   = (*m_data)[level][iter];
            m_ops[level][iter].generateTags(tags_i, U0_i);
        }
        tags.setDomainBoundary(0);
        newGrids.addFinerTags(tags, level);
        AMRGrid::buffer(tags, Point::Ones(m_bufferSize[level]));
        newGrids.regrid(tags, level);
    }
    for (int level = max(2, a_baseLevel); level < newGrids.numLevels(); level++)
    {
        newGrids.enforceNesting2(level);
    }
    auto dx0 = m_ops[0].dx();
     int a_level = a_baseLevel;
    
    m_data->regrid(newGrids, a_baseLevel, OP::order());
    
    define(*m_data, m_ops[a_baseLevel].dx(), a_baseLevel,
           m_regridInterval[a_baseLevel],m_bufferSize[a_baseLevel]);            
}
