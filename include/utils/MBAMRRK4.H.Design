
#ifndef _PROTO_MBAMR_RK4__
#define _PROTO_MBAMR_RK4__
#define RKORDER 4
#define RKNUMSTAGES 4
#include "Proto.H"

extern int TIME_STEP;
extern int PLOT_NUM;

template< template<typename, MemType> class OpType,
          typename T,
          MemType MEM=MEMTYPE_DEFAULT>
class AMRRK4
{
    public:
    typedef OpType<T, MEM> OP; 
    typedef BCType<T,OP::numState(), MEM, PR_CELL> BC;
    typedef LevelOp<OpType, double, BCType, MEM> LOP;
    typedef MBLevelBoxData<T, OP::numState(), MEM> LevelStateData;
    typedef AMRData<T, OP::numState(), MEM> AMRStateData;
  
    inline AMRRK4(){}
    inline AMRRK4(AMRStateData& a_data, const Array<T, DIM>& a_dx,
                  int a_regridInterval = 1, int a_bufferSize=2);
    inline void define(AMRStateData& a_data, const Array<T, DIM>& a_dx,
                       int a_regridInterval = 1, int a_bufferSize=2);
    inline void define(AMRStateData& a_data, const Array<T, DIM>& a_dx, int a_level,
                     int a_regridInterval = 1, int a_bufferSize=2);
    inline void advance(T a_dt);
    inline void advance(int a_level, T a_dt, T a_chi);
    inline void UTimeInterp(LevelStateData& a_UCoarsened,
                          int a_level,
                          int a_stage,
                          T a_chi);
  inline void StageLevel(
                         LevelStateData& a_kstage,
                         const LevelStateData& a_UStage,
                         T a_dt,
                         T a_time,
                         int a_level,
                         int a_stage);
    
    inline void regrid(int a_baseLevel);
    
    Array<double, RKNUMSTAGES>     m_stageWeights = {1./6.,1./3.,1./3.,1./6.};
    Array<double, RKNUMSTAGES>   m_chi = {0.,1./2.,1./2.,1.};
    
    std::shared_ptr<AMRStateData> m_data;

    std::vector<T> m_dt;
    std::vector<T> m_time;
    std::vector<int> m_timeRefRatios;
    std::vector<Point> m_spaceRefRatios;
    std::vector<LOP> m_ops;
    std::vector<int> m_numSteps;
    std::vector<int>  m_regridInterval;
    std::vector<int>  m_bufferSize;
    std::vector<InterpStencil<T> > m_cfInterp;
  
    std::vector<std::shared_ptr<LevelStateData>> m_UStage;
    std::vector<std::shared_ptr<MBLevelBoxData<T, OP::numState()*RKNUMSTAGES, MEM>>> m_UTaylor;
    std::vector<std::shared_ptr<MBLevelBoxData<T, OP::numState()*RKNUMSTAGES, MEM>>> m_UTaylorC;
   std::vector<std::shared_ptr<MBLevelFluxRegister<T, OP::numState(), MEM>>> m_fluxRegisters;
    std::vector<std::shared_ptr<MBLevelFluxRegister<T, OP::numState(), MEM>>> m_blockRegisters;
  // We also want member data that hold the MBInterpOps for each level,
  // and the MBInterpOps used to generate data on the next coarser level for
  // interpolation.
};
#include "AMRRK4Implem.H"
#endif //end include guard
