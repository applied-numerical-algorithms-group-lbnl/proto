#include "Proto.H"
#include "UnitTest.H"
#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <cmath>

#define _USE_MATH_DEFINES

using namespace Proto;
using namespace std;
int main(int argc, char** argv)
{
    if (argc == 2)
    {
        s_verbosity = atoi(argv[1]);
    } else {
        s_verbosity = 0;
    }

    cout << "What would you like to test?" << endl;
    cout << "\tTest Set 1: Point" << endl;
    cout << "\tTest Set 2: Box" << endl;
    cout << "\tTest Set 3: BoxData" << endl;
    cout << "\tTest Set 4: Stencil" << endl;
    cout << "\tTest Set 5: InterpStencil" << endl;
    cin >> TEST;

    //***********************************
    //  POINT TESTS
    //***********************************
    BEGIN_TEST_SUITE(1,"Proto::Point");
    
    //===================================
    BEGIN_TEST("Default Construction");
    Point p;
    if (s_verbosity > 1)
    {
        cout << "Default constructed Point: " << p << endl;
    }
    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p[ii] == 0);
    }
    END_TEST();
    
    //===================================
    BEGIN_TEST("Default Construction");
    std::array<int,DIM> v;
    for (int ii = 0; ii < DIM; ii++)
    {
        v[ii] = (ii+1)*17;
    }
    Point p(v);
    if (s_verbosity > 1)
    {
        cout << "Building Array from [";
        for (int ii = 0; ii < DIM; ii ++)
        {
            cout << v[ii] << ", ";
        }
        cout << "]: " << p << endl;
    }
    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p[ii] == v[ii]);
    }
    END_TEST();
    
    //===================================
    BEGIN_TEST("Variadic Construction");
    Point p(1,2,3,4,5,6);
    if (s_verbosity > 1)
    {
        cout << "Building Point from [";
        for (int ii = 0; ii < DIM; ii ++)
        {
            cout << ii+1 << ", ";
        }
        cout << "]: " << p << endl;
    }
    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p[ii] == ii+1);
    }
    END_TEST(); 
    
    //===================================
    BEGIN_TEST("Copy Construction");
    Point p(1,2,3,4,5,6);
    Point q(p);
    if (s_verbosity > 1)
    {
        cout << "Constructing Point initial Point " << p <<": ";
        cout << q << endl;
    }
    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p[ii] == q[ii]);
        unitTest(&p[ii] != &q[ii]);
    }
    END_TEST();
    
    //===================================
    BEGIN_TEST("Static Methods");
    Point p0 = Point::Zeros();
    Point p1 = Point::Ones();
    Point p2 = Point::Ones(17);
    Point p3 = Point::Basis(0);
    Point p4 = Point::Basis(DIM-1,17);
    
    if (s_verbosity > 1)
    {
        cout << "Point::Zeros(): " << p0 << endl; 
        cout << "Point::Ones(): " << p1 << endl; 
        cout << "Point::Ones(17): " << p2 << endl; 
        cout << "Point::Basis(0): " << p3 << endl; 
        cout << "Point::Basis("<<DIM-1<<", 17): " << p4 << endl; 
    }
    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p0[ii] == 0);
        unitTest(p1[ii] == 1);
        unitTest(p2[ii] == 17);
        if (ii == 0){unitTest(p3[ii] == 1);}
        else {unitTest(p3[ii] == 0);}
        if (ii == DIM - 1){unitTest(p4[ii] == 17);}
        else {unitTest(p4[ii] == 0);}
    }
    END_TEST(); 

    //===================================
    BEGIN_TEST("Accessor Methods");
    Point p(1,2,3,4,5,6);
    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p[ii] == ii+1);
    }
    const Point q(1,2,3,4,5,6);
    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(q[ii] == ii+1);
    }
    END_TEST();
   
    //===================================
    BEGIN_TEST("Algebraic Operators");
    Point p0(1,2,3,4,5,6);
    Point p1;
    int flip = -1;
    for (int ii = 0; ii < DIM; ii++)
    {
        p1[ii] = p0[ii]*17*flip;
        flip *= -1;
    }

    Point p2 = p0 + p1;
    if (s_verbosity > 1)
    {
        cout << p0 << " + " << p1 << " = " << p2 << endl;
    }

    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p2[ii] == (p0[ii] + p1[ii]));
    }
    
    p2 = p1 - p0;
    if (s_verbosity > 1)
    {
        cout << p1 << " - " << p0 << " = " << p2 << endl;
    }

    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p2[ii] == (p1[ii] - p0[ii]));
    }

    p2 = p1*p0;
    if (s_verbosity > 1)
    {
        cout << p1 << " * " << p0 << " = " << p2 << endl;
    }

    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p2[ii] == (p1[ii]*p0[ii]));
    }

    p2 = p1/p0;
    if (s_verbosity > 1)
    {
        cout << p1 << " / " << p0 << " = " << p2 << endl;
    }

    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p2[ii] == (p1[ii]/p0[ii]));
    }

    p2 = p1/17;
    if (s_verbosity > 1)
    {
        cout << p1 << " / 17 = " << p2 << endl;
    }

    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p2[ii] == (p1[ii]/17));
    }

    p1 = Point::Ones(2); 
    p2 = p0 % p1;
    if (s_verbosity > 1)
    {
        cout << p0 << " % " << p1 << " = " << p2 << endl;
    }

    for (int ii = 0; ii < DIM; ii++)
    {
        unitTest(p2[ii] == (p0[ii] % p1[ii]));
    }


    END_TEST();
     
    END_TEST_SUITE();
    
    //***********************************
    //  BX TESTS
    //***********************************
    BEGIN_TEST_SUITE(2,"Proto::Bx");
    //===================================
    BEGIN_TEST("Default Constructor");
    Bx B;
    if (s_verbosity > 1)
    {
        cout << "Default Constructed Bx: " << B << endl;
    }
    unitTest(B.low() == Point::Zeros());
    unitTest(B.high() == Point::Ones(-1));
    unitTest(B.size() <= 0);
    END_TEST();

    //===================================
    BEGIN_TEST("Point Constructors");
    Point p1(1,2,3,4,5,6);
    Point p0 = (-1)*p1;
    Bx B0(p1,p0);
    Bx B1(p0,p1);
    Bx B2(p1);
    if (s_verbosity > 1)
    {
        cout << "Bx(" << p1 << ", " << p0 << "): " << B0 << " ";
        cout << "size() = " << B0.size() << endl;
        cout << "Bx(" << p0 << ", " << p1 << "): " << B1 << " ";
        cout << "size() = " << B1.size() << endl;
        cout << "Bx(" << p1 << "): " << B2 << " ";
        cout << "size() = " << B2.size() << endl;
    }
    
    int s1 = 1; int s2 = 1;
    for (int ii = 0; ii < DIM; ii++)
    {
        s1 *= (p1[ii] - p0[ii] + 1);
        s2 *= (p1[ii] + 1);
    }
    unitTest(B0.size() <= 0);
    unitTest(B0.empty());
    unitTest(B1.size() == s1);
    unitTest(!B1.empty());
    unitTest(B2.size() == s2);
    unitTest(!B2.empty());

    END_TEST();
    
    //===================================
    BEGIN_TEST("Copy Constructor");
    Bx B0(Point(1,2,3,4,5,6));
    Bx B1(B0);
    if (s_verbosity > 1)
    {
        cout << "Building Bx from " << B0 << ": " << B1 << endl;
    }
    unitTest(B0 == B1);
    unitTest(&B0 != &B1); 
    END_TEST();

    //===================================
    BEGIN_TEST("Static Methods");
    int size = 17;
    Bx B = Bx::Cube(size);
    if (s_verbosity > 1)
    {
        cout << "Bx::Cube(" << size << "): " << B << endl;
    }
    unitTest(B.size() == ipow<DIM>(size));
    unitTest(B.low() == Point::Zeros());
    unitTest(B.high() == Point::Ones(size-1));
    END_TEST();

    //===================================
    BEGIN_TEST("Iteration and Indexing");
    Point max = Point(1,2,3,4,5,6);
    Point min = -1*max;
    Bx B(min,max);
    
    int index = 0;
    Point p = min;
    if (s_verbosity > 1)
    {
        cout << "Iterating through Box " << B << endl << endl;
    }
    for (auto iter = B.begin(); iter != B.end(); ++iter, ++index)
    {
        if (s_verbosity > 1){cout << *iter << " ";}
        unitTest(*iter == p);
        unitTest(B.index(*iter) == index);
        ++p[0];
        for (int ii = 0; ii < DIM-1; ii++)
        {
            if (p[ii] > max[ii])
            {
                if (s_verbosity > 1){cout << endl;}
                p[ii] = min[ii];
                ++p[ii+1];
            }
        }
    }

    p = max;
    if (s_verbosity > 1)
    {
        cout << "Inverse Iterating through Box " << B << endl << endl;
    }
    index = B.size()-1;
    for (auto iter = B.rbegin(); iter != B.rend(); --iter, --index)
    {
        if (s_verbosity > 1)
        {
            cout << *iter << " ";
        }
        unitTest(*iter == p);
        unitTest(B.index(*iter) == index);
        --p[0];
        for (int ii = 0; ii < DIM-1; ii++)
        {
            if (p[ii] < min[ii])
            {
                if(s_verbosity > 1){cout << endl;}
                p[ii] = max[ii];
                --p[ii+1];
            }
        }
    }
    END_TEST();

    //===================================
    BEGIN_TEST("Shift");
    Bx b0 = Bx::Cube(16);
    Point s(1,-2,3,-4,5,-6);
    
    Bx b1 = b0.shift(s);
    if (s_verbosity > 1)
    {
        cout << "Shifting " << b0 << " by " << s << ": " << b1 << endl; 
    }
    unitTest((b0.low() + s) == b1.low());
    unitTest((b0.high() + s) == b1.high());
    unitTest(&b0 != &b1);
    unitTest(b0 == Bx::Cube(16)); //should be unchanged
    END_TEST();
    
    //===================================
    BEGIN_TEST("Grow");
    Bx b0 = Bx::Cube(16);
    Point s(1,-2,3,-4,5,-6);
    //Grow (Point)
    Bx b1 = b0.grow(s);
    if (s_verbosity > 1)
    {
        cout << "Growing " << b0 << " by " << s << ": " << b1 << endl;
    }
    unitTest((b0.low() - s) == b1.low());
    unitTest((b0.high() + s) == b1.high());
    unitTest(&b0 != &b1);
    unitTest(b0 == Bx::Cube(16)); //should be unchanged
    
    //Grow (scalar)
    b1 = b0.grow(3);
    if (s_verbosity > 1)
    {
        cout << "Growing " << b0 << " by " << 3 << ": " << b1 << endl;
    }
    unitTest((b0.low() - 3) == b1.low());
    unitTest((b0.high() + 3) == b1.high());
    unitTest(&b0 != &b1);
    unitTest(b0 == Bx::Cube(16)); //should be unchanged
    END_TEST();
    
    //===================================
    BEGIN_TEST("Coarsen"); 
    Point low = Point::Ones(-2);
    Point high = Point::Ones(3);
    Point r = Point::Ones() + Point::Basis(0); //(2,1,1,...,1)
    Bx b0 = Bx(low,high); 
    Bx b1 = b0.coarsen(2); 
    Bx b2 = b0.coarsen(3);
    Bx b3 = b0.coarsen(r);
    if (s_verbosity > 1)
    {
        cout << "Coarsen " << b0 << " by 2: " << b1 << endl;
        cout << "Coarsen " << b0 << " by 3: " << b2 << endl;
        cout << "Coarsen " << b0 << " by " << r << ": " << b3 << endl;
    }
    unitTest(b1.low() == b0.low()/2);
    unitTest(b1.high() == b0.high()/2);
    unitTest(b2.low() == b0.low()/3);
    unitTest(b2.high() == b0.high()/3);
    unitTest(b3.low()[0] == b0.low()[0]/2);
    unitTest(b3.high()[0] == b0.high()[0]/2);
    for (int ii = 1; ii < DIM; ii++)
    {
        unitTest(b3.low()[ii] == b0.low()[ii]);
        unitTest(b3.high()[ii] == b0.high()[ii]);
    }
    unitTest(&b0 != &b1);
    unitTest(&b0 != &b2);
    unitTest(&b0 != &b3);
    unitTest(b0 == Bx(low,high));
    END_TEST();
    
    //===================================
    BEGIN_TEST("Refine"); 
    Point low = Point::Ones(-2);
    Point high = Point::Ones(3);
    Point r = Point::Ones() + Point::Basis(0); //(2,1,1,...,1)
    Bx b0 = Bx(low,high);
    Bx b1 = b0.refine(2);
    Bx b2 = b0.refine(3);
    Bx b3 = b0.refine(r);
    if (s_verbosity > 1)
    {
        cout << "Refine " << b0 << " by 2: " << b1 << endl;
        cout << "Refine " << b0 << " by 3: " << b2 << endl;
        cout << "Refine " << b0 << " by " << r << ": " << b3 << endl;
    }
    unitTest(b1.low() == b0.low()*2);
    unitTest(b1.high() == (b0.high()+Point::Ones())*2-Point::Ones());
    unitTest(b2.low() == b0.low()*3);
    unitTest(b2.high() == (b0.high()+Point::Ones())*3-Point::Ones());
    unitTest(b3.low()[0] == b0.low()[0]*2);
    unitTest(b3.high()[0] == (b0.high()[0]+1)*2 - 1);
    for (int ii = 1; ii < DIM; ii++)
    {
        unitTest(b3.low()[ii] == b0.low()[ii]);
        unitTest(b3.high()[ii] == b0.high()[ii]);
    }
    unitTest(&b0 != &b1);
    unitTest(&b0 != &b2);
    unitTest(&b0 != &b3);
    unitTest(b0 == Bx(low,high));

    END_TEST();
    
    //===================================
    BEGIN_TEST("Flatten"); 
    Bx b0 = Bx::Cube(17);
    for (int ii = 0; ii < DIM; ii++)
    {
        Bx b1 = b0.flatten(ii);
        Bx b2 = b0.flatten(ii,true);
        if (s_verbosity > 1)
        {
            cout << "Down - flattening axis " << ii << " of " << b0;
            cout << ": " << b1 << endl;
            cout << "Up - flattening axis " << ii << " of " << b0;
            cout << ": " << b2 << endl;
        }
        unitTest(b1.low() == b0.low());
        unitTest(b2.high() == b0.high());
        for (int jj = 0; jj < DIM; jj++)
        {
            if (jj == ii)
            {
                unitTest(b1.high()[jj] == b1.low()[jj]);
                unitTest(b2.low()[jj] == b2.high()[jj]);
            } else {
                unitTest(b1.high()[jj] == b0.high()[jj]);
                unitTest(b2.low()[jj] == b0.low()[jj]);
            }
        }
    }
    END_TEST();

    //===================================
    BEGIN_TEST("Extrude"); 
    Bx b0 = Bx::Cube(17);
    for (int ii = 0; ii < DIM; ii++)
    {
        Bx b1 = b0.extrude(ii,3);
        Bx b2 = b0.extrude(ii,3,true);
        if (s_verbosity > 1)
        {
            cout << "Down - extruding axis " << ii << " of " << b0;
            cout << ": " << b1 << endl;
            cout << "Up - extruding axis " << ii << " of " << b0;
            cout << ": " << b2 << endl;
        }
        unitTest(b1.high() == b0.high());
        unitTest(b2.low() == b0.low());
        for (int jj = 0; jj < DIM; jj++)
        {
            if (jj == ii)
            {
                unitTest(b1.low()[jj] == b0.low()[jj]-3);
                unitTest(b2.high()[jj] == b0.high()[jj]+3);
            } else {
                unitTest(b1.low()[jj] == b0.low()[jj]);
                unitTest(b2.high()[jj] == b0.high()[jj]);
            }
        }
    }
    END_TEST();
    
    //===================================
    BEGIN_TEST("Mod"); 
    Point high(1,2,3,4,5,6);
    Point low = high*(-1);
    Bx B(low,high);
    
    Point p0 = Point::Zeros(); 
    Point p1(1,2,3,4,5,6);
    Point p2 = high+Point::Ones();
    Point p3 = low-Point::Ones();
    Point p4 = B.flatten(0).high() - Point::Basis(0);
    Point p5 = B.flatten(0,true).low() + Point::Basis(0);
    
    Point q0 = B.mod(p0);
    Point q1 = B.mod(p1);
    Point q2 = B.mod(p2);
    Point q3 = B.mod(p3);
    Point q4 = B.mod(p4);
    Point q5 = B.mod(p5);
    
    if (s_verbosity > 1)
    {
        cout << B << " mod " << p0 << " = " << q0 << endl;
        cout << B << " mod " << p1 << " = " << q1 << endl;
        cout << B << " mod " << p2 << " = " << q2 << endl;
        cout << B << " mod " << p3 << " = " << q3 << endl;
        cout << B << " mod " << p4 << " = " << q4 << endl;
        cout << B << " mod " << p5 << " = " << q5 << endl;
    }


    unitTest(q0 == p0);
    unitTest(q1 == p1);
    unitTest(q2 == low);
    unitTest(q3 == high);
    unitTest(q4 == high);
    unitTest(q5 == low);
    
    END_TEST();
    END_TEST_SUITE();
    
    //**********************************
    //  BOXDATA TESTS
    //**********************************
    BEGIN_TEST_SUITE(3,"Proto::BoxData");
    END_TEST_SUITE();
    
    //*********************************
    //  STENCIL TESTS
    //**********************************
    
    BEGIN_TEST_SUITE(4,"Proto::Stencil");
    
    //===================================
    BEGIN_TEST("Default Constructor"); 
    Stencil<double> S;
    Bx B = Bx::Cube(8);
    if (s_verbosity > 1)
    {
        cout << "Default Stencil: " << endl;
        S.print();
    }
    std::vector<Point> offsets = S.offsets(); 
    std::vector<double> coefs = S.coefs();
    unitTest(offsets.size() == 0);
    unitTest(coefs.size() == 0);
    unitTest(S.span() == Bx(Point::Zeros(), Point::Ones(-1))); 
    END_TEST();
    
    //===================================
    BEGIN_TEST("Shift Constructor + Stencil Addition"); 
    Stencil<double> S = 1.0*Shift::Zeros() + 
                      + 5.0*Shift::Zeros() + 2.0*Shift::Ones()
                      + 3.0*Shift::Basis(0,2) + 4.0*Shift(6,5,4,3,2,1);
    if (s_verbosity > 1)
    {
        cout << "Building the Stencil: " << endl;
        cout << 1.0 << " * " << Point::Zeros() << " + ";
        cout << 5.0 << " * " << Point::Zeros() << " + ";
        cout << 2.0 << " * " << Point::Ones() << " + ";
        cout << 3.0 << " * " << Point::Basis(0,2) << " + ";
        cout << 4.0 << " * " << Point(6,5,4,3,2,1) << endl;
        S.print();
    }
    std::vector<Point> offsets = S.offsets(); 
    std::vector<double> coefs = S.coefs();
    
    unitTest(offsets.size() == 4);
    unitTest(coefs.size() == 4);

    int index = 0; 
    index = std::distance(offsets.begin(),
            std::find(offsets.begin(), offsets.end(), Point::Zeros()));
    unitTest(index < offsets.size());
    unitTest(coefs[index] == 6.0);
    
    index = std::distance(offsets.begin(),
            std::find(offsets.begin(), offsets.end(), Point::Ones()));
    unitTest(index < offsets.size());
    unitTest(coefs[index] == 2.0);
    
    index = std::distance(offsets.begin(),
            std::find(offsets.begin(), offsets.end(), Point::Basis(0,2)));
    unitTest(index < offsets.size());
    unitTest(coefs[index] == 3.0);
    
    index = std::distance(offsets.begin(),
            std::find(offsets.begin(), offsets.end(), Point(6,5,4,3,2,1)));
    unitTest(index < offsets.size());
    unitTest(coefs[index] == 4.0);
    END_TEST();
    
    //===================================
    BEGIN_TEST("Stencil Scalar Multiplication"); 
    Stencil<double> S0 = 1.0*Shift::Basis(0,-1)
                       - 2.0*Shift::Zeros()
                       + 1.0*Shift::Basis(0,1);
    auto S1 = 17.0*S0;
    if (s_verbosity > 1)
    {
        cout << "Initial Stencil S: " << endl;
        S0.print();
        cout << "S * 17.0: " << endl;
        S1.print();
    }
    
    std::vector<Point> offsets = S1.offsets(); 
    std::vector<double> coefs = S1.coefs();
    
    unitTest(offsets.size() == 3);
    unitTest(coefs.size() == 3);

    int index = 0; 
    index = std::distance(offsets.begin(),
            std::find(offsets.begin(), offsets.end(), Point::Basis(0,-1)));
    unitTest(index < offsets.size());
    unitTest(coefs[index] == 17.0);
    
    index = std::distance(offsets.begin(),
            std::find(offsets.begin(), offsets.end(), Point::Zeros()));
    unitTest(index < offsets.size());
    unitTest(coefs[index] == -34.0);
    
    index = std::distance(offsets.begin(),
            std::find(offsets.begin(), offsets.end(), Point::Basis(0,1)));
    unitTest(index < offsets.size());
    unitTest(coefs[index] == 17.0);
     
    END_TEST();
    //===================================
    BEGIN_TEST("Stencil Composition"); 
    Stencil<double> S0 = 2.0*Shift::Basis(0);
    Stencil<double> S1 = 1.0*Shift::Basis(0,-1)
                       - 2.0*Shift::Zeros()
                       + 1.0*Shift::Basis(0,1);
    auto S2 = S0*S1;
    Stencil<double> S3 = 2.0*Shift::Zeros()
                       - 4.0*Shift::Basis(0,1)
                       + 2.0*Shift::Basis(0,2);
    if (s_verbosity > 1)
    {
        cout << "Composing the following two Stencils: " << endl;
        S0.print();
        S1.print();
        cout << "Resulting Stencil:" << endl;
        S2.print();
    }
    unitTest(S2 == S3);
    
    END_TEST();
    
    //===================================
    #if DIM > 1
    BEGIN_TEST("Transpose"); 
    Stencil<double> S0 = 1.0*Shift::Basis(1)
                       - 2.0*Shift::Zeros()
                       + 3.0*Shift::Basis(0,-1)
                       - 4.0*Shift::Ones();
    
    if (s_verbosity > 1)
    {
        cout << "Transposing the Stencil: " << endl;
        S0.print();
    }
    S0.transpose(0,1);
    if (s_verbosity > 1)
    {
        cout << "Resulting Stencil: " << endl;
        S0.print();
    }
    Stencil<double> S1 = 1.0*Shift::Basis(0)
                       - 2.0*Shift::Zeros()
                       + 3.0*Shift::Basis(1,-1)
                       - 4.0*Shift::Ones();
    unitTest(S0 == S1);
    END_TEST();
    #else
    OMIT_TEST("Stencil::transpose","Set DIM > 1 to run test");
    #endif
    
    //===================================
    BEGIN_TEST("Domain and Range"); 
    
    Bx B = Bx::Cube(16).shift(Point::Ones());
    Bx R, D;
    
    // 2*DIM + 1 Point Laplacian
    Stencil<double> S0 = (-2.0*DIM)*Shift::Zeros();
    for (int ii = 0; ii < DIM; ii++)
    {
        int d = ii+1;
        S0 += 1.0*Shift::Basis(ii,d);
        S0 += 1.0*Shift::Basis(ii,-d);
    }
    
    R = S0.range(B);
    D = S0.domain(B);
    if (s_verbosity > 1)
    {
        cout << "Computing Domain and Range of Stencil: " << endl;
        S0.print();
        cout << "Input: " << B << endl;
        cout << "Domain: " << D << endl;
        cout << "Range: " << R << endl;
    }
    unitTest(R == B.grow(Point(1,2,3,4,5,6)*-1));
    unitTest(D == B.grow(Point(1,2,3,4,5,6)));

    //-----------------------------------
    // Linear Average
    Stencil<double> S1;
    Bx K = Bx::Cube(3);
    for (auto iter = K.begin(); iter != K.end(); ++iter)
    {
        S1 += 1.0*Shift(*iter);
    }
    S1.srcRatio() = Point::Ones(3);
    
    Bx r = Bx::Cube(3).shift(Point::Ones());
    Bx d = Bx(Point::Ones(2), Point::Ones(13));

    R = S1.range(d);
    D = S1.domain(r);
    if (s_verbosity > 1)
    {
        cout << "Computing Domain and Range of Stencil: " << endl;
        S1.print();
        cout << "Domain of " << r << ": " << D << endl;
        cout << "Range of " << d << ": " << R << endl;
    }
    unitTest(R == Bx(Point::Ones(), Point::Ones(3)));
    unitTest(D == Bx(Point::Ones(3), Point::Ones(11)));

    //-----------------------------------
    // Linear Interp
    Stencil<double> S2 = (2.0/3)*Shift::Zeros() + (1.0/3)*Shift::Basis(0);
    S2.destRatio() = Point::Ones(3);
    S2.destShift() = Point::Basis(0);
    
    r = Bx(Point::Ones(2), Point::Ones(12));
    d = Bx(Point::Ones(), Point::Ones(4));
    R = S2.range(d);
    D = S2.domain(r);
    if (s_verbosity > 1)
    {
        cout << "Computing Domain and Range of Stencil: " << endl;
        S2.print();
        cout << "Domain of " << r << ": " << D << endl;
        cout << "Range of " << d << ": " << R << endl;
    }
    unitTest(R == Bx(Point(4,3),Point(10,12)));    
    unitTest(D == Bx(Point::Ones(), Point::Ones(4)));
    END_TEST();

    //===================================
    BEGIN_TEST("Apply: Scalar Multiply");
    Stencil<double> S = 17.0*Shift::Zeros();
    Bx B = Bx::Cube(8);
    auto R = forall_p<double>([](Point p, Var<double> v)
    {
        v(0) = 1;
        for (int ii = 0; ii < DIM; ii++)
        {
            v(0) += p[ii];
        }
    },B);
    BoxData<double> D0 = S(R);
    Bx b = B.grow(-Point::Basis(0));
    BoxData<double> D1 = S(R,b);
    if (s_verbosity > 1)
    {
        #if DIM > 2
        cout << "Output is suppressed for DIM > 2" << endl;
        #else
        cout << "Applying Stencil: " << endl;
        S.print();
        cout << "Source Data: " << endl;
        R.print();
        cout << "Output with automatic Box: " << endl;
        D0.printData();
        cout << "Output on Bx " << b << endl;
        D1.printData();
        #endif
    }
    
    unitTest(D0.box() == B);
    unitTest(D1.box() == b);

    for (auto iter = B.begin(); iter != B.end(); ++iter)
    {
        unitTest(D0(*iter) == 17.0*R(*iter));
        if (b.contains(*iter))
        {
            unitTest(D1(*iter) == 17.0*R(*iter));
        }
    }
    END_TEST();
    
    //===================================
    BEGIN_TEST("Apply: Laplacian"); 
    Stencil<double> S0 = (-2.0*DIM)*Shift::Zeros();
    for (int ii = 0; ii < DIM; ii++)
    {
        S0 += 1.0*Shift::Basis(ii,+1);
        S0 += 1.0*Shift::Basis(ii,-1);
    }

    int numIter = 4;
    double error[numIter];
    
    int domainSize = 8;
    for (int ii = 0; ii < numIter; ii++)
    {
        double dx = M_PI/domainSize;
        Bx b = Bx::Cube(domainSize);
        Bx B = S0.domain(b);
        
        double ddx = dx*dx;
        auto S = S0*(1.0/ddx);

        auto R = forall_p<double>([dx](Point p, Var<double>& v)
        {
            v(0) = sin(p[0]*dx);
            #if DIM > 1
            v(0) += cos(p[1]*dx);
            #endif
        },B);
       
        BoxData<double> D0 = S(R);
        BoxData<double> D1 = S(R,b.grow(-Point::Basis(0)));
        BoxData<double> D2(B,1337);
        D2 |= S(R);
        BoxData<double> D3(B,17);
        D3 += S(R);
        
        unitTest(D0.box() == b);
        unitTest(D1.box() == b.grow(-Point::Basis(0)));
        unitTest(D2.box() == B);
        unitTest(D3.box() == B);
        
        for (auto iter = B.begin(); iter != B.end(); ++iter)
        {
            if (b.contains(*iter))
            {
                unitTest(abs(D2(*iter) - D0(*iter)) < 0.01);
                unitTest(abs(D3(*iter) - D0(*iter) - 17) < 0.01);
            } else {
                unitTest(D2(*iter) == 1337);
            }
            if (D1.box().contains(*iter))
            {
                unitTest(abs(D1(*iter) - D0(*iter)) < 0.01);
            }
        }

        D0 += R;
        error[ii] = D0.absMax();
        domainSize *= 2;
    }

    double rates[numIter-1];
    for (int ii = 1; ii < numIter; ii++)
    {
        rates[ii-1] = log2(error[ii-1]/error[ii]);
        if (s_verbosity > 1)
        {
            cout << "Error: " << error[ii] << " Rate: " << rates[ii-1] << endl; 
        }
    }
    unitTest(abs(rates[numIter-2] - 2) < 0.1);

    END_TEST();
    
    //===================================
    BEGIN_TEST("Apply: Average"); 
    Bx K = Bx::Cube(2);
    Stencil<double> S;
    double coef = 1.0/K.size();
    for (auto iter = K.begin(); iter != K.end(); ++iter)
    {
        S += coef*Shift(*iter);
    }
    S.srcRatio() = Point::Ones(2);

    
    int domainSize = 16;
    Bx B0 = Bx::Cube(domainSize);
    Bx B1 = S.range(B0);

    auto Src = forall_p<double>([](Point p, Var<double>& v)
    {
        v(0) = 0;
        for (int ii = 0; ii < DIM; ii++)
        {
            v(0) += p[ii];
        }
    },B0);
   
    auto Soln = forall_p<double>([](Point p, Var<double>& v)
    {
        v(0) = 0;
        for (int ii = 0; ii < DIM; ii++)
        {
            v(0) += 2.0*p[ii];
        }
        v(0) += 1;
    },B1);
   
    BoxData<double> D0 = S(Src);
    BoxData<double> D1 = S(Src,B1.grow(-Point::Basis(0)));
    BoxData<double> D2(B1,1337);
    D2 |= S(Src);
    BoxData<double> D3(B1,17);
    D3 += S(Src);
    
    unitTest(D0.box() == B1);
    unitTest(D1.box() == B1.grow(-Point::Basis(0)));
    unitTest(D2.box() == B1);
    unitTest(D3.box() == B1);
    
    for (auto iter = B1.begin(); iter != B1.end(); ++iter)
    {
        unitTest(Soln(*iter) == D0(*iter));
        unitTest(abs(D2(*iter) - D0(*iter)) < 1e-6);
        unitTest(abs(D3(*iter) - D0(*iter) - 17) < 1e-6);
        if (D1.box().contains(*iter))
        {
            unitTest(abs(D1(*iter) - D0(*iter)) < 1e-6);
        }
    }
   
    END_TEST();
    END_TEST_SUITE();
    
    //***********************************
    //  INTERPSTENCIL TESTS
    //***********************************
    BEGIN_TEST_SUITE(5,"Proto::InterpStencil");
    
    //===================================
    BEGIN_TEST("Default Constructor"); 
    InterpStencil<double> IS;
    unitTest(IS.empty());
    unitTest(IS.kernel().size() <= 0);
    END_TEST();
    //===================================
    BEGIN_TEST("Standard Constructor");
    Point r = Point(2,3,4,5,6,7);
    InterpStencil<double> IS(r);
    unitTest(IS.kernel() == Bx(r - Point::Ones()));
    END_TEST();
    //===================================
    BEGIN_TEST("PiecewiseConstant and PiecewiseLinear");
    Point r = Point::Ones(3);
    auto PWC = InterpStencil<double>::PiecewiseConstant(r);
    auto PWL = InterpStencil<double>::PiecewiseLinear(r);
    
    int domainSize = 16;
    int numIter = 4;
    double error_C[numIter];
    double error_L[numIter];
    for (int ii = 0; ii < numIter; ii++)
    {
        Bx B0 = Bx::Cube(domainSize);
        Bx B1 = Bx(B0.low()*r, B0.high()*r);
        Bx B2 = B0.refine(r);
        BoxData<double> Src(B0);
        BoxData<double> DC0(B2,1337);
        BoxData<double> DL0(B1,1337);
        BoxData<double> DC1(B2,17);
        BoxData<double> DL1(B1,17);
        BoxData<double> Soln(B2);
        
        //double dx = (M_PI/4.0)/domainSize;
        double dx = 1.0/domainSize;
        forallInPlace_p([dx](Point p, Var<double>& v)
        {
            //v(0) = p[0]*dx;
            v(0) = sin(dx*p[0]);
            #if DIM > 1
            v(0) *= cos(dx*p[1]);
            #endif
            
        },Src);
        
        forallInPlace_p([dx](Point p, Var<double>& v)
        {
            //v(0) = p[0]*dx/3.0;
            v(0) = sin(dx/3.0*p[0]);
            #if DIM > 1
            v(0) *= cos(dx/3.0*p[1]);
            #endif
        },Soln);

        DC0 |= PWC(Src);
        DL0 |= PWL(Src);
        DC1 += PWC(Src);
        DL1 += PWL(Src);
        BoxData<double> DC2 = PWC(Src);
        BoxData<double> DL2 = PWL(Src);
    
        unitTest(DC2.box() == B2);
        unitTest(DL2.box() == B1);
        DC0 -= DC2;
        DL0 -= DL2;
        DC1 -= 17;
        DL1 -= 17;
        DC1 -= DC2;
        DL1 -= DL2;

        unitTest(DC0.absMax() < 1e-6);
        unitTest(DL0.absMax() < 1e-6);
        unitTest(DC1.absMax() < 1e-6);
        unitTest(DL1.absMax() < 1e-6);
        DC2 -= Soln;
        DL2 -= Soln;
        error_C[ii] = DC2.absMax();
        error_L[ii] = DL2.absMax();
        domainSize *= 2;
    }
    
    for (int ii = 1; ii < numIter; ii++)
    {
        double rate = log2(error_C[ii-1]/error_C[ii]);
        unitTest(abs(rate - 1) < 0.1);
        if (s_verbosity > 1)
        {
            cout << "PWC Error: " << error_C[ii] << " Rate: " << rate << endl;
        }
    }
    for (int ii = 1; ii < numIter; ii++)
    {
        double rate = log2(error_L[ii-1]/error_L[ii]);
        unitTest(abs(rate - 2) < 0.1);
        if (s_verbosity > 1)
        {
            cout << "PWL Error: " << error_L[ii] << " Rate: " << rate << endl;
        }
    }
      
    END_TEST();
    END_TEST_SUITE();
}
