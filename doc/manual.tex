\documentclass[12pt]{article}
\title{Proto Design Document}
\author{Chris L. Gebhart\\Phil Colella \\ Brian Van Straalen}

\usepackage{manual}
\oddsidemargin=-.125in
\evensidemargin=-.125in
\textwidth=6.5in
\topmargin=-0.5in
\textheight=8.5in
\parskip 3pt
\nonfrenchspacing

\begin{document}
\lstset{language=C++,style=protostyle}
\maketitle

\section{Introduction}

\libname is a lightweight library designed for efficient solution of differential equations on domains composed of unions of structured, logically rectangular grids. The goal of \libname is to provide a fluent, intuitive interface that separates the complexities of \textit{designing} and \textit{scheduling} an algorithm. As both the tools and applications of high performance computing become continuously more intricate, libraries such as \libname will become more and more necessary to efficiently solve problems in a timely manner. 

\section{Variables, Notation, and Syntax}

In general, variables which refer to tokens in \libname are written using a \code{monospaced font}. Vector-like objects are written in lower-case $\mbf{bold}$, number types use black-board font ($\mbb{R}$), and sets are written in math calligraphy font ($\mathcal{S}$). Occasionally words are typed in bold-face simply for \textbf{emphasis}. 

\begin{center}
\begin{tabular}{||c c||}
\hline
Variable Name & Variable Definition \\
\hline\hline
$\DIM$ or \code{DIM} & Number of space dimensions \\
$\mbb{Z}^\DIM$ & $\DIM$-dimensional Space of Integers \\
$\mbf{B}$ & Rectangular subset of $\mbb{Z}^\DIM$\\
${\rm Box}(V)$ & Domain of multidimensional rectangular array $V$\\
$[\mbf{l}, \mbf{h}]$ &  Box with low and high corners ($\mbf{l}$, $\mbf{h}$)\\
$\mbb{T}$ & Space of numbers of type \code{T}\\

$\mbf{i,j,k,r,s,t \dots}$ & Points in $\mathbb{Z}^{\DIM}$ \\
$\mbf{e}^d$ & Unit vectors in direction $d$\\
$\mbf{u}$ & Point in $\mathbb{Z}^\DIM$ all of whose entries are 1 \\
\hline
\end{tabular}
\end{center}

\section{Spatial Discretizations on Rectangular Grids}

%The \libname library focuses on \textbf{stencil} and \textbf{pointwise} computations within a \textbf{single patch} on \textbf{structured}, \textbf{logically 
%rectangular} grids. We proceed by defining each of the emphasized terms above. 
We approximate solutions to partial differential equations in terms of \textbf{data arrays}, i.e. discrete values defined over rectangular regions (Boxes) in $\mbb{Z}^\DIM$.
\begin{gather}
\phi:\mbf{B} \rightarrow \mathcal{T} \hbox{ i.e., } \phi_\mbf{i} \in \mathcal{T} \cma 
\mbf{i} \in \mbf{B} \subset \mbb{Z}^\DIM , \label{eqn:rectArr}\\ 
\mathcal{T} = \mathcal{T}(C_1, \dots , C_n) = \{t_{c_1, \dots , c_n}: t \in \mbb{T}, c_j \in [1, \dots , C_j]\}, \label{eqn:codomain}.
\end{gather}
where $\mbb{T}$ is one of the real numbers ($\mbb{R}$), the complex numbers ($\mbb{C}$), or the integers ($\mbb{Z}$), and $\mbf{B} = [\mbf{l},\mbf{h}]$ is a rectangular subset of $\mbb{Z}^\DIM$ with low and high corners $\mbf{l},\mbf{h}$. Thus $\phi$ takes on values in a space of multidimensional arrays of $\mbb{T}$s.While we could flatten this into a single array of dimension $\DIM + n$, we choose not to. This is because the different indices have different mathematical meanings. The Box indices represent a discretization of physical space, with those indices used to define difference approximations to derivatives. The indices in $\mathcal{T}$ represent different components in some state space. A second difference is that the range of indices for the Boxes are computed at run time, whereas we will assume that the range of component indices for any given $\phi$ are known at compile time. Multidimensional arrays have the usual algebraic operations asociated with them:
\begin{itemize}
\item
\underline{Assignment.} If $\phi$, $\psi$ are data arrays with the same value space $\mathcal{T}$, we define the assignment operator 
\begin{gather*}
\psi := \phi \on \mbf{B}' \Leftrightarrow \psi_\mbf{i} := \phi_\mbf{i} \cma \mbf{i} \in \mbf{B}'\\
 \mbf{B}'\subseteq \MBox(\phi) \cap \MBox(\psi)
\end{gather*}
If the qualifier $\hbox{\bf{ on }} \dots$ is omitted, then the assignment is assumed to take place on  $\MBox(\phi) \cap \MBox(\psi)$.
\item
\underline{Addition of two data arrays; multiplication of a data array by a scalar}. If $\phi$, $\psi$ have the same value spaces, then $\phi + \psi$ is defined on $\MBox(\phi) \cap \MBox(\psi)$, with 
$(\psi + \phi)_\mbf{i} = \psi_\mbf{i} + \phi_\mbf{i}$. If $t \in \mbb{T}$, then 
$(t \phi )_\mbf{i} = t \phi_\mbf{i}$. 
\end{itemize}

A broad range of discretized PDE operators can be represented as the composition of
\textbf{stencil} and \textbf{pointwise} operations applied to data arrays. 

The simplest example of a stencil operator is given by 
\begin{gather*}
\psi := S(\phi)  \on \mbf{B}' \cma S(\phi)_\mbf{i} = 
\sum \limits_{\mbf{s} \in \mcl{S}} a_\mbf{s} \phi_{\mbf{i} + \mbf{s}},
\end{gather*}
where the coefficients $a_\mbf{s} \in \mbb{T}$, $\mcl{S}$ is a finite subset of $\mbb{Z}^\DIM$, and $\mbf{B}' \subseteq \cap_{\mbf{s} \in \mcl{S}} (\mbf{B}(\phi)- \mbf{s})$. Such operators appear as finite difference approximations to constant-coefficient differential operators. For multilevel algorithms such as AMR and multigird, we will want more general versions of stencil operators corresponding to strided access through the data array. A more general form of such a stencil is given by
\begin{gather*}
\psi := S(\phi)  \on \mbf{B}' \\
 S(\phi)_{\mbf{r}^{d} \mbf{i} + \mbf{t}} = 
\sum \limits_{\mbf{s} \in \mcl{S}} a_\mbf{s} \phi_{\mbf{r}^{s}\mbf{i} + \mbf{s}} \cma
\mbf{i} \in \mbf{B}'
\end{gather*}
where $\mbf{r} \mbf{i} = (r_0 i_0 , \dots , r_{\DIM-1} i_{\DIM-1}) \in \mbb{Z}^\DIM$. Note that, if $\mbf{r}^d \neq \mbf{u}$, the application of the stencil assigns values to a strided subset of the data array on the left-hand side. 

While the action of stencil on an a data array depend on the inputs, stencils themselves, as specified by the collection of offsets and weights $\{(\mbf{s},a_\mbf{s}): \mbf{s} \in \mcl{S}\}$ and the input and output stride and output offset $(\mbf{r}^s, \mbf{r}^d, \mbf{t})$ have a mathematical meaning independent of the inputs. In particular, if $\mbf{r}^s, \mbf{r}^d = \mbf{1}$, and $\mbf{t} = \mbf{0}$, stencils can be added, multiplied by scalars, and composed to obtain new stencils. 
\begin{gather*} 
S = t S_1 + S_2 \Leftrightarrow
S(\phi)_\mbf{i} = \sum \limits_{\mbf{s} \in \mcl{S}_1 \cup \mcl{S}_2} 
(t a^1_{\mbf{s}} + a^2_{\mbf{s}}) \phi_{\mbf{i} + \mbf{s}} \\
S = S_1 \cdot S_2 \Leftrightarrow S (\phi)_\mbf{i} = \sum \limits_{\mbf{s}\in \mcl{S} } ,
(\sum \limits_{\mbf{s}_1,\mbf{s}_2: \mbf{s}_1 + \mbf{s}_2 = \mbf{s}} a^1_{\mbf{s}_1}  a^2_{\mbf{s}_2} ) \phi_{\mbf{i} + \mbf{s}} \cma \mcl{S} = \{\mbf{s}_1 + \mbf{s}_2: \mbf{s}_1 \in \mcl{S}_1 , \mbf{s}_2 \in \mcl{S}_2\}.
\end{gather*}
Algebraic operations and composition enables the construction of complex stencils from simpler ones as a symbolic preprocessing step.

Pointwise operators are defined using functions of one or more variables of the form \eqref{eqn:codomain}. Given 
\begin{gather*}
F: \mathcal{T}_1 \times \dots \times \mathcal{T}_P \rightarrow \mathcal{T}
\end{gather*}
we define $F@$, the pointwise operator derived from $F$, to be 
\begin{gather*}
\psi = F@(\phi^1 , \dots, \phi^P) \on \mbf{B}' \Leftrightarrow 
\psi_\mbf{i} = F(\phi^1_\mbf{i}, \dots , \phi^P_\mbf{i}) \cma \mbf{i} \in \mbf{B}'\\
\mbf{B}' \subseteq \mbf{B}(\psi) \cap \mbf{B}(\phi^1) \cap \dots \cap \mbf{B}(\phi^P)
\end{gather*}

%We represent such arrays in \libname with the class \code{DataBox}:


%\textbf{Stencil} computations are algorithmic elements in which a value at a spatial point $\mbf{i}$ is updated with a linear combination of itself and values at neighboring spatial points holding the component constant. A very general mathematical definition of a stencil operation is shown in Equation \ref{eqn-stencil-def-general}. This definition allows for the source data $U$ and or the destination data $V$ to be refined. In the case where $V$'s domain is refined, the complete stencil is composed of $\mbf{r}_d^{\DIM}$ partial stencils, each of which produces a strided portion of the final solution. (IMAGE GREATLY NEEDED HERE)
%
%\begin{equation}
%\label{eqn-stencil-def-general}
%V_{\mbf{r}_d\mbf{i} + \mbf{t}} =
%\sum_{\mbf{s}\in\mcl{S}}(w_{\mbf{s}}^\mbf{t}U_{\mbf{r}_s\mbf{i} + \mbf{s}})
%\quad\mbf{t}\in\mbf{B}(\mbf{0},\mbf{r}_d - \mbf{1})
%\end{equation}
%
%In the absence of any sort of refinement, Equation \ref{eqn-stencil-def-general} reduces to Equation \ref{eqn-stencil-def-noref}, the traditional linear combination definition of a linear stencil operation.
%
%\begin{equation}
%\label{eqn-stencil-def-noref}
%V_{\mbf{i}} = \sum_{\mbf{s}\in\mcl{S}}(w_{\mbf{s}}U_{\mbf{i} + \mbf{s}})
%\end{equation}
%
%In general, a stencil operation will require data points outside of its domain of application. As a result, the source data $U$ must be defined on a space $\mbf{B}(U)\supset\mbf{B}(V)$. The difference between these two spaces $\mbf{B}(U) - \mbf{B}(V)\equiv\mbb{G}(S)$ is a set of points called \textbf{ghost cells}\footnote{In some communities these are called "halo cells"}

%a \textbf{pointwise function} is a (often non-linear) function of one or more components of any number of input arrays $U_k$ all evaluated at a specific grid point $\mbf{i}$ to yield an output $V$. Where a stencil combines data of a fixed component at several different grid points, a pointwise function combines the components of its argument(s) while holding the grid point constant. Equation \ref{eqn-pointwise-op} provides a generalized signature for a pointwise function.
%
%\begin{equation}
%\label{eqn-pointwise-op}
%V = F(\mbf{i}, U_0, U_1, ...)_{\mbf{i}} = F(\mbf{i} ,<params>, U_0(c,d,...), U_1(c,d,...), ...)
%\end{equation}
%
%Unlike with stencils, a pointwise function cannot be described in any general way (e.g. a list of coefficients and offsets) and must be explicitly defined. Additionally, a pointwise function may also take mathematical constants or scalars as arguments, including the point $\mbf{i}$ itself. 
%
%A third class of operation relevent in the current context is the \textbf{reduction} operation which combines the data from a number of components of a number of datasets into a single value. Averages and extrema computations are examples of reduction operations. \libname allows for computation of reductions using the \code{forall} function. 
%
%A \textbf{structured} grid is a mesh with regular connectivity which can, as a result of regularity, be easily stored in memory in array form without explicit connectivity information.  A structured grid is an alternative to an \textbf{unstructured grid} which is defined by an irregular connectivity that must be explicitly stored in memory.
%
%There are several tradeoffs between structured and unstructured grids. Structured grids have the benefit smaller memory footprint, better spatial locality, and (often) better algorithmic convergence. They also tend to be very easy to coarsen and refine for the purposes of adaptive methods. Unstructured grids on the other hand are very good for modelling irregular domains, a property which has greatly contributed to their popularity. [PROBABLY THERE ARE MORE THINGS TO ADD HERE, SHOULD ADD EXAMPLE IMAGE OF BOTH GRIDS]
%
%A subset of structured grids are \textbf{logically rectangular} and can be represented as a collection of $\DIM$-dimensional intervals in $\mbb{Z}^\DIM$. That is to say, each grid cell is an $\DIM$-dimensional rectangle. Note that the *physical* space represented by the grid need not have rectangular cells, so long as a mapping exists onto a rectangular grid.
%
%a \textbf{patch} of a \textbf{logically rectangular} grid refers to the smallest rectangular subdivision of the grid, and often coincides with the region of a the problem assigned to a single parallel process (e.g. each patch of the grid might be processed by an MPI process). In terms of \libname objects, a \code{BoxData} usually corresponds to a single patch.
%
%\libname is a \textbf{single patch} library which is to say that structures for collections of patches, communication between patches, and operations on multiple patches are outside scope and must be defined by the user or provided by other software packages such as CHOMBO.  

\section{\libname Structures}

There are four C++ classes that implement a representation of spatial discretizations on rectangular grids described above.
\begin{itemize}
\item
\code{Point} represents points in $\mbb{Z}^\DIM$.
\item
\code{Box} represents rectangular subsets of $\mbb{Z}^\DIM$.
\item
\code{BoxData<T,C,D,E>} represents data arrays of the form
\begin{gather*}
\phi:\mbf{B} \Rightarrow \mathcal{T} \cma \mathcal{T}(\mathbb{T},C,D,E).
\end{gather*}
\code{BoxData} is a templated class, with class templates specifying the values taken on by the array, and the dimensions of the range space $\mathcal{T}$ given by \code{C,D,E}. 
\item
\code{Stencil} is a class that defines stencils as self-contained objects.
\end{itemize}
We provide a more detailed summry of these classes below. The full documentation is contained in the Doxygen-annotated header files for \libname.
\subsection{\code{Point}}

A \code{Point} is a vector in $\mbb{Z}^\DIM$. \libname uses \code{Points} to define locations in a grid as well as offsets between grid cells. The number of component axes of a \code{Point} - and all the objects which depend on \code{Point} - is determined from the compile-time constant \code{DIM}. 

\begin{itemize}
\item
\underline{Construction and Assignment}. 
\item
\underline{Arithmetic Operators}. 
\code{Points} have addition, componentwise multiplication, multiplication and division by an integer (in the latter case, with rounding toward $-\infty$).
\item
\underline{Logical Operators}.
\code{p1 == p2}, \code{p1 != p2}. The inequality operators e.g. \code{p1 >  p2} return true if they are true for each pair of components, i.e. the usual partial ordering on $\mbb{Z}^\DIM$.
\item
\underline{Indexing Operators}.
\code{p[d]}, $d = 0, \dots , \DIM-1 $. returns the $d^{th}$ component of \code{p}. \code{p[d]} can appear as the left-hand side in an assignment.
\end{itemize}
%The $i^{th}$ component of a \code{Point} $\mbf{p}$ is written $p_i$ where $i\in\left[0,\dots , \DIM - 1\right]$. Points are written using the syntax $\mbf{p} = \left(p_0, p_1, ... , p_{\DIM -1}\right)$. \code{Points} in \libname are mutable objects, and components of a \code{Point} can be accessed and changed using \code{[]} access analogous to other array-like objects in C++.
%
%\libname allows \code{Point} creation through various means as shown in Listing \ref{lst-make-point}. Note that the variadic integer constructor will create a \code{Point} from the first \code{DIM} arguments. For example, \code{Point(1,2,3,4,5)} creates the \code{Point} $(1,2,3)$ when \code{DIM = 3}, the \code{Point} $(1,2)$ when \code{DIM = 2}, etc.
%
%\begin{lstlisting}[caption=Methods for Creating Points, label=lst-make-point]
%// DIM = 3
%// Create Point using integers:
%Point p0 = Point(1,2,3);        //p0 = (1,2,3)
%// Create Point using array literal:
%Point p1 = Point({1,2,3});      //p1 = (1,2,3)
%
%// Create Point from static methods:
%Point zero = Point::Zeros();	//zero = (0,0,0)
%Point ones = Point::Ones();		//ones = (1,1,1)
%Point threes = Point::Ones(3);	//threes = (3,3,3)
%Point ntwos = Point::Ones(-2);  //ntwos = (-2,-2,-2)
%Point e = Point::Basis(0);		//e = (1,0,0)
%Point v = Point::Basis(1,-3);	//v = (0,-3,0) 
%\end{lstlisting}
%
%Addition, subtraction, multiplication, division, and modulus operators are defined between two \code{Points} and between a \code{Point} and an \code{int}. All operators are computed componentwise. 

\subsection{\code{Box}}

A \code{Box} is an $\DIM$ dimensional interval in $\mbb{Z}^{\DIM}$.

\begin{itemize}
\item
\underline{Constructors}. \code{Box(low,high)}, where \code{low, high} are \code{Points}. If \code{(high >= low) == false}, then the \code{Box} is an empty \code{Box}.
\item
\underline{Logical Functions and Accessors}.
\code{B1 == B2}, \code{B1 != B2}, \code{contains(Point a\_pt)}, \\ \code{onBoundary(Point a\_pt)}, \code{empty()} all return \code{bool}s. 
\item
\underline{Transformations and Set Operations}. \code{B1 \& B2} returns the intersection of the two \code{Box}es. \code{coarsen}, \code{refine}, \code{shift} and other transformation operations compute \code{Box}es needed to construct \code{BoxData} targets for various structured-grid algorithms.
\end{itemize}
\subsection{BoxData}

A \code{BoxData<T,C,D,E>} represents a data array defined on a \code{Box} domain of the form \eqref{eqn:rectArr}
\begin{gather*}
U:\mbf{B} \rightarrow \mathcal{T} \cma \mathcal{T} = \mathcal{T}(C,D,E),
\end{gather*}
where $C$, $D$, and $E$ are positive integers which define the sizes of \textit{component axes} 0, 1, and 2 respectively. These values define the nature of data in a \code{BoxData} as shown below:

\begin{itemize}
\item: $C=D=E=1\rightarrow$ Scalar
\item: $C>1, D=E=1\rightarrow$ Vector (1st Order Tensor) of length $C$
\item: $C,D>1, E=1\rightarrow$ $C\times D$ Matrix (2nd Order Tensor)
\item: $C,D,E>1\rightarrow$ $C\times D\times E$ 3rd Order Tensor
\end{itemize}

\code{BoxData} has an accompanying class \code{Interval<C,D,E>} which represents the analog of \code{Box} in \textit{component space}. \code{Interval} facilitates copy and slicing operations on \code{BoxData}s.

A full set of algebraic operations are defined between \code{BoxData}s as well as between \code{BoxData}s and scalars of type \code{T}. Additional operations include the following:

\begin{itemize}
\item \code{setVal}: Sets all values equal to a given scalar
\item \code{copyTo}: Copies a subset of \code{*this} into another \code{BoxData}.
\item \code{linearIn} and \code{linearOut}: Reads and writes data from a subset of \code{*this} into a \code{void*} array. Useful for communication. 
\item \code{min}, \code{max}, and \code{absMax}: Computes the min, max, or absolute max of \code{*this}
\item \code{iota}: Creates a \code{BoxData<T,DIM>} from a \code{Box} and a step size of type \code{T} that represents a space of position vectors in $\mbb{T}^N$.
\item \code{slice} and \code{alias}: Create \code{BoxData} subsets from existing \code{BoxData}s without copying data. 
\item \code{forall}: Pointwise function application. See next section.
\end{itemize}

\subsubsection{Var, Param, and Forall}

The function \code{forall} takes as a function \code{F}, a \code{Box}, and any 
number of \code{BoxData}s or scalar parameters. The \code{BoxData} inputs need not have the same coordinate layout (e.g. $C$, $D$, and $E$ may differ) and they may have different domain \code{Box}es. The \code{Box} argument may be omitted, in which case \code{F} will be computed on the intersection of the domians of all \code{BoxData} inputs. The input \code{F} may be a user defined function or an in-place lambda function. Either way, \code{F} must have the syntax:
\begin{align*}
\text{\code{void F(Var<T0,C0,D0,E0>\& V, Args...)}}
\end{align*}

Where $V$ represents an output \code{BoxData} and \code{Args...} may contain any number of \code{Var<T,C,D,E>} and/or \code{Param<T>} objects each of which correspond to an input \code{BoxData<T,C,D,E>} or a scalar parameter of type \code{T}, respectively. Elements of \code{Args...} may be declared \code{const} or not, as needed.

Inside the body of \code{F}, the value of a \code{Param} may be accessed using the \code{operator()} function and used/updated as would any value of type \code{T}. A \code{Var} object represents a \code{BoxData} evaluated at a \code{Point}. Inside the body of \code{F}, a \code{Var} can be indexed into exactly like a \code{BoxData} but with the \code{Point} argument omitted. See the examples below for an illustration of how \code{BoxData}, \code{Var}, \code{Param} and \code{forall} are related. 

[REALIZING AT THE TIME OF WRITING THAT IN-PLACE FORALL NEEDS TO BE LOOKED AT, AS WELL AS FORALL\_P]

\begin{lstlisting}[caption=Forall Usage with External Function, label=lst-forall-foo]
//DIM=2
using namespace Proto;
// A simple pointwise function
void foo(Var<double>& C,
		 const Var<double,2>& A,
	     const Var<double,2>& B,
		 Param<double> max)
{
	// Initialize the output array
	C(0) = 0;
	// Add the sum of the components of A
	C(0) += (A(0) + A(1));
	// Multiply by the difference of B's components
	C(0) *= (B(0) - B(1));
	// Simultaneously compute the max of C
	max = ((C(0) > max) ? C(0) : max);
}

//...

int main(int argc, char** argv)
{
	// define a Box b
	BoxData<double,2> RA(b), RB(b);
	// initialize RA, RB, and max (sources)
	
	// the template parameters of forall
	// are the same as the output BoxData
	auto RC = forall<double>(foo,b,RC,RA,RB,max);
	// RC now contains the result of applying foo:q

}
\end{lstlisting}

\begin{lstlisting}[caption=Forall Usage With Lambda, label=lst-forall-lambda]
//DIM=2
using namespace Proto;
// ...define the Box B...
Box b = B.grow(-1) //b is smaller than B
// define U with domain B, initialize to 4
BoxData<double,2,3> U(B,4);
double scale = 0.5;

// Call forall
auto V = forall<double,2,3>(
[scale](Var<double,2,3>& v, const Var<double>& u) //lambda start
{
	for (int ii = 0; ii < 2; ii++V)
	for (int jj = 0; jj < 3; jj++)
	{
		v(ii,jj) += u(0)*scale
	}
	return 2*2*3;
},b,U); //end lambda, other arguments

\end{lstlisting}

\subsection{Stencil}

A \code{Stencil<T>}\footnote{From this point, the template parameter \code{T} will be omitted for the sake of brevity} is an object that encapsulates a linear stencil operation with coefficients of type \code{T}. \code{Stencil}s are constructed using a companion class \code{Shift} which represents the grid shifts associated with a stencil operation. \code{Stencil}s are created using \code{operator*(T coef,Shift shift)} which produces an atomic \code{Stencil} object with one coefficient \code{coef} and associated offset \code{shift}. These atomic \code{Stencil}s are added together to create the final \code{Stencil}. An example of this process is shown in Listing \ref{lst-stencil-construct}

\begin{lstlisting}[caption=Stencil Construction, label=lst-stencil-construct]
// DIM=2
using namespace Proto;

// 2nd Order Second Derivative along axis 0:
Stencil<double> D2 = 1.0*Shift::Basis(0) +
					1.0*Shift::Basis(0,-1) +
					(-2.0)*Shift::Zeros();

// 2nd Order Laplacian:
Stencil<double> L = (-2.0*DIM)*Shift::Zeros();
Box b = Box::Cube(3).shift(Point::Ones(-1));
for (auto iter = b.begin(); iter != b.end(); ++iter)
{
	if (*iter != Point::Zeros())
		L += 1.0*Shift(*iter);
}
\end{lstlisting}
Any \code{Stencil} can be created using the idiom detailed above, however there are a number of \code{Stencil}s implemented as static functions of the class \code{Stencil} including \code{Stencil<T>::Derivative(...)}, \code{Stencil<T>::Laplacian(...)}, and various interpolation \code{Stencil}s useful finite volume applications.

A \code{Stencil} operates on a \code{BoxData} using \code{Stencil<T>::operator()} combined with an assignment, increment ($+=$), or replacement($|=$) operator. A \code{Box} argument defining the range of the operation may also be supplied, but is usually unnecessary. When the \code{Box} argument is omitted, the \code{Stencil} will be applied to the largest valid domain, taking any necessary ghost cells into account. The \code{Stencil} class also has member functions \code{Stencil::domain(Box range)} and \code{Stencil::range(Box domain)} that will compute a \code{Stencil}'s domain from  a desired range and vice versa. Listing \ref{lst-stencil-apply} demonstrates \code{Stencil} application in \libname .

\begin{lstlisting}[caption=Stencil Application, label=lst-stencil-apply]
 //2nd order Laplacian
Stencil<double> L = Stencil<double>::Laplacian();

int rangeSize = 64; //desired size of output
Box b = Box::Cube(rangeSize);
// define the source array with necessary ghost cells
BoxData<double> U(L.domain(b));

// ... initialize a source BoxData U ... 

// Apply L using assignment:
BoxData<double> V = L(U);

// Apply L using replacement:
BoxData<double> W1(b);
W1 |= L(U);

// Apply L using increment
BoxData<double> W2(b,0); //must initialize!
W2 += L(U);
 
\end{lstlisting}

\subsection{Interface to \code{Chombo}}

Our initial implementation of \code{Proto} provides a replacement for the single-rectangle operations that have traditionally been written in Fortran. In order to obtain a more representative set of use cases, be have provided an interim mechanism for coupling to the existing \code{Chombo} tools for managing structured-grid calculations on CPU-based distributed-memory systems. Specifically, have provided an alias between the existing \code{Chombo} multidimensional array class \code{BaseFAB} and the \code{Proto} \code{BoxData}. In this case, one can use existing \code{Chombo} tools to implement distributed-memory examples, while using \code{Proto} to replace the Fortran calls. As we move this to GPU-based systems, we are modifying \code{Chombo} to account for device and host memory in its definition of distributed data on unions of rectangles, and in particular will allow the construction of \code{LevelData<DataBox>} to represent distributed data on unions of rectangles directly.

\section{Common Idioms}

\subsection{Building Boxes}

\code{Boxes} in \libname can be built in various ways. The \code{Box(Point high)} and \code{Box(Point low, Point high)} constructors are useful for creating a known \code{Box}. The \code{Box::Cube(int size)} function is a shortcut for building an isotropic \code{Box} of known size with \code{low} at the origin. Finally, \code{Box}es can be computed by chaining transforms together. This can be more convenient when the precise bounds of the desired \code{Box} are not the most convenient definition. All of these methods are illustrated in Listing \ref{lst-box-construct}.

\begin{lstlisting}[caption=Box Construction Idiom, label=lst-box-construct]
//DIM=2
using namespace Proto;

// Building Boxes with constructors:
Box B0(Point(1,2),Point(3,4)); //B0 = [(1,2),(3,4)]
Box B1(Point(5,5)); // B1 = [(0,0),(5,6)]

// Building Boxes with Box::Cube
Box B2 = Box::Cube(4); B2 = [(0,0),(3,3)];

// Building Boxes by chaining transforms:
Box B3 = Box::Cube(4)			//cube of size 4
		.shift(Point({1,2})     //move the origin
		.grow(Point::Basis(0));	//stretch on axis 0

\end{lstlisting}

\subsection{Building Stencils}

Like \code{Box}es, \code{Stencil}s can also be constructed with various methods. Smaller \code{Stencil}s can easily be constructed as a sum of coefficient-shift products. For more complex \code{Stencil}s - and especially when dimensional independence is desired - it can be very convenient to use a \code{Box} as a kernel as shown in Listing \ref{lst-stencil-construct}. 

\begin{lstlisting}[label=lst-stencil-construct, caption=Stencil Construction Methods]

//DIM=2
using namespace Proto;

Stencil<double> S0, S1;
// Build a Stencil from a coefficient-Shift sum:
S0 = 1.0*Shift::Basis(0)
   +(-2.0)*Shift::Zeros()
   + 1.0*Shift::Basis(0,-1);
   
// Build a Stencil using a Box kernel:
//   The kernel Box is [(-1,-1),(1,1)]
Box K = Box::Cube(3).shift(Point::Ones(-1)) 
for (auto iter = K.begin(); iter != K.end(); ++iter)
{
	if (*iter == Point::Zeros())
		S1 += (-2.0*ipow<DIM>(2))*Shift(*iter);
	else
		S1 += 1.0*Shift(*iter);
}
S1 *= 1.0/3.0; //multiply all coefficients by 1/3;

\end{lstlisting}



\end{document}
